# 算法题型总结(基于leetcode前400和剑指offer)

### sum问题
sum问题在算法中出现的比较频繁，问题通常可以描述为是在某个数据结构(数组、链表、树等)中找到固定数量的几个数或不固定数量的几个数相加，得到最终的目标值
* **两数之和(leetcode 1)**：找到数组中两个数相加和为一个目标值
    *1.暴力解法*：对数组中每个元素遍历一次整个数组，时间复杂度O($n^2$)，空间复杂度O(1)；
    *2.哈希表解法*：遍历一次数组，在哈希表中查找是否存在$target-nums[i]$的键值存在，如果不存在，则将数组当前值和索引存入哈希表；若存在，直接返回当前索引和哈希表对应键值的索引。
* **三数之和(leetcode 15)**：找到数组中三个数相加和为一个目标值
    *1.暴力解法*：维护三个指针，依次对数组进行遍历，时间复杂度O($n^3$)，空间复杂度O(1);
    *2.双指针*：排序+双指针，时间复杂度O($n^2$)，空间复杂度O(1)
* **最近的三数之和(leetcode 16)**：找到数组中三个数相加的和最接近某个目标值
    *1.暴力解法*：维护三个指针，依次对数组遍历，并比较与目标值最近的三数之和，时间复杂度O($n^3$)，空间复杂度O(1)；
    *2.双指针*：排序+双指针，时间复杂度O($n^2$)，空间复杂度O(1)
* **四数之和(leetcode 18)**：找到数组中四个树的和相加为某个目标值
    *1.暴力解法*：维护四个指针，依次对数据遍历，时间复杂度O($n^3$)，空间复杂度O(1);
    *2.双指针*：排序+双指针，时间复杂度O($n^3$)，空间复杂度O(1)
* **四数之和II(leetcode 484)**：在四个数组中分别取一个元素和为目标值
    *1.暴力解法*：维护四个指针依次遍历每个数组，时间复杂度为O($n^4$)，空间复杂度为O(1);
    *2.哈希映射*；将四个数组两两分组，相加的结构存入哈希表查询，时间复杂度O($n^2$，空间复杂度O($n$))
* **组合相加(leetcode 39)**：数组中任意个元素相加和为目标值，数组中元素均不相同，同一个数能被多次取到
    *回溯法*：从数组中第一个值开始进行枚举，同一个数能被多次选取，注意当和大于目标值就进行剪枝，时间复杂度为O(S)，S为所有可行解的长度和，空间复杂度为栈的深度，最差为O(target)
* **组合相加II(leetcode 40)**：数组中任意个元素相加和为目标值，数组中每个元素只能被用一次
    *回溯法*：将数组进行排序再枚举，当某个数字的前一个元素已经被选取过，那么跳过当前元素，同样根据当前和大于目标值进行剪枝，时间复杂度为O($2^nn$)，空间复杂度为O(n)
* **组合相加III(leetcode 216)**：1-9任意k个不重复数字相加和为目标值
    *1.暴力解法*：类似于多数之和的形式，嵌套多层循环，时间复杂度为O($10^k$)，空间复杂度为O(1)
    *2.回溯法*：组合相加的常见套路，不同的是终止条件要改为固定长度和固定长度子集的和为目标值，时间复杂度为O(S*k)，S为组合数，空间复杂度度为O(S)
* **组合相加IV(leetcode 377)**：数组中任意个元素相加和为目标值，数组中元素均不相同，同一个数能被多次取到，不同的排布顺序被记为不同的结果
    *1.回溯法*：与leetcode 39组合相加不同的是相同的解法不同的排布顺序被记为不同的解，因此递归的循环中要从整个数组的头部重新寻找，其余的与上述解法无不同之处
    *2.动态规划*：典型的完全背包问题，$dp[i] = sum(dp[i-nums[j]])，其中dp[0] = 0$，时间复杂度为O(nm)，空间复杂度为O(m)
* **最小路径和(leetcode 64)**：二维数组从左上角到右下角的最短路径和，每次只能向下或者向右走
    *动态规划*：典型的动态规划问题，$dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]$，时间复杂度为O(mn)，空间复杂度为O(mn)
* **路径和(leetcode 112)**：树中从根结点到叶子结点的路径和为某一个值
    *1.广度优先搜索*：用两个队列分别存储遍历到的结点值以及遍历到该结点时根结点到此结点的路径和，时间复杂度为O(n)，空间复杂度为O(n)
    *2.深度优先搜索*：递归的终止条件为空节点或者到叶子结点的和为目标值，时间复杂度O(n)，空间复杂度为O(H)
* **路径和II(leetcode 113)**：打印树中从根结点到叶子结点路径和为某一个值的所有路径
    *深度优先搜索*：与路径和类似，多了一个需要存储路径的数组，每次遍历左右子树的时候需要将结点的值添加到数组中，遍历完再移除，时间复杂度为$O(N^2)$，空间复杂度为O(N)
* **路径和III(leetcode 437)**：树中某一条路径的和为目标值，起止结点无需是根结点和叶子结点
    *深度优先搜索*：保存前缀和，每次遍历到某个结点就将根结点到此结点的路径和存储到hash表中，遍历hash表查询当前路径和与hash表中的差值是否等于目标值，时间复杂度为O($N^2$)，空间复杂度为O(N)
* **划分相等子数组和(leetcode 416)**：将一个数组划分为两个子数组，两个子数组的和相等
    *动态规划*：经典的背包问题，可以用动态规划求解，$dp[i]=dp[i-nums[j]]$，时间复杂度为O(nm)，空间复杂度为O(m)
* **目标和(leetcode 494)**：通过给指定数组中每个元素分配加减号，得到最终的目标值
    *深度优先搜索*：对数组进行枚举，每个元素有加和减两种枚举选择，时间复杂度O($2^n$)，空间复杂度O(n)
    *动态规划*：可以转换为01背包问题，假设最终结果正数和为x，负数和绝对值为y，那么target=x-y，而sum=x+y，那么x=(target+sum/2)，即为在数组中取出值为x的取法，与组合相加IV解法相同，时间复杂度O(mn)，空间复杂度O(m)
               


### 背包问题
最最典型的动态规划问题，可以根据数组中的元素是否能重复使用分为01背包和完全背包问题,重复使用nums数组放在内循环，不允许重复使用nums数组放在外循环
* **组合相加IV(leetcode 377)**：数组中任意个元素相加和为目标值，数组中元素均不相同，同一个数能被多次取到，不同的排布顺序被记为不同的结果
    *动态规划*：典型的完全背包问题，$dp[i] = sum(dp[i-nums[j]])，其中dp[0] = 1$，时间复杂度为O(nm)，空间复杂度为O(m)
* **目标和(leetcode 494)**：通过给指定数组中每个元素分配加减号，得到最终的目标值
    *动态规划*：可以转换为01背包问题，假设最终结果正数和为x，负数和绝对值为y，那么target=x-y，而sum=x+y，那么x=(target+sum/2)，即为在数组中取出值为x的取法，与组合相加IV解法相同，时间复杂度O(mn)，空间复杂度O(m)
* **零钱兑换II(leetcode 518)**：给定一定面值大小的零钱和一个需要兑换的大面值纸币，假设每种面值的零钱数量无限，不同的排列顺序视为一种方式
    *动态规划*：这是一个完全背包问题，但由于不同排列顺序记为同一个方法，是为排序数而不是组合数，外层循环发生改变，$dp[i]=sum(dp[i-nums[j]])$，时间复杂度为O(mn)，空间复杂度为O(m)
* **爬楼梯(leetcode 70)**：爬楼梯到指定的台阶，一次只能爬一步或者两步
    *动态规划*：上面组合相加IV问题的缩减版，将数组替换为[1，2]即可，时间复杂度O(n)，空间复杂度O(1)
* **单词拆分(leetcode 139)**：判断一个字符串数组能否组合成一个大的字符串，数组中的元素能被重复使用
    *动态规划*：是一个完全背包问题，用回溯法会超时，递归表达式为$dp[i]=dp[j]&&check(s[j+1, i])$，时间复杂度为O($n^2$)，空间复杂度为O(n)
* **划分相等子数组和 (leetcode 416)**：将一个数组划分为两个和相等的子数组
    *动态规划*：o1背包问题，可以用动态规划求解，$dp[i]=dp[i-nums[j]]$，时间复杂度为O(nm)，空间复杂度为O(m)
* **0和1(leetcode 474)** ：给定一个数组，里面的字符串只包含0和1，找出最大子集，其中包含的0和1的数量分别不超过m和n
    *动态规划*：01背包问题，不同的是限定条件是为二维的，其余的解法与01背包问题相同，时间复杂度为O(nmk)，空间复杂度为O(mnk)，k为数组大小
* **零钱兑换(leetcode 322)**：给定一定面值大小的零钱和一个需要兑换的大面值纸币，假设每种面值的零钱数量无限，求出需要的最少零钱数量
    *动态规划*：完全背包问题，
    
### 链表问题
链表问题是面试中经常会考的问题，一般会有递归和迭代两种解决办法，迭代思路比较简单，递归的思路就比较绕
* **两链表相加(leetcode 2)**：将两个链表视为两个整数，相加得到整数的和
    *迭代相加*：思路较为简单，从最低位开始一步步相加，注意最高位的可能产生多余的进位，时间复杂度O(max(m,n))，空间复杂度O(1)

### 双指针
一般在字符串或者数组内通过双指针来判断子数组、子串是否存在重复
* **无重复字符的最长子串**：
    *双指针解法*：双指针从左到右滑动，通过一个哈希表来记录两个指针间出现的元素，有重复元素左指针右移并将值从哈希表移出，无重复元素右指针向右移动将值添加
                         至哈希表，时间复杂度为O(n)，空间复杂度为O(E),E为ASCII的大小

### 动态规划


    